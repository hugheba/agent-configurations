# Spring Boot 3 Rules

Guidelines for building modern Spring Boot 3.x services with a focus on GraalVM native image readiness, performance, observability, and maintainability. These extend the JVM Common Rules.

## Baseline

- Spring Boot: 3.x (keep patch versions current)
- Java: 17 (LTS) or 21 (preferred when using virtual threads) – never below 17
- Jakarta EE 9+ namespace migration (`jakarta.*`) complete – no lingering `javax.*`
- Prefer Kotlin for new services; Java acceptable for existing or performance‑sensitive hotspots
- Use Gradle Kotlin DSL (`build.gradle.kts`)

## Project Structure

- Follow layered or hexagonal architecture: `api`, `application/service`, `domain`, `infrastructure`
- Keep controller classes thin – delegate to services/use-cases
- Group configuration by feature not by stereotype when it improves cohesion
- Avoid cyclic dependencies between modules / packages

## Dependency Management

- Use Spring Boot dependency management – avoid hardcoding versions managed by the BOM
- Keep dependency footprint minimal (native image size & build time)
- Avoid reflection-heavy libraries unless necessary; prefer Spring-native supported libraries
- For JSON: prefer Jackson (already optimized) or Kotlin serialization (if fully Kotlin). Avoid Gson.
- Use `spring-boot-starter-validation` (Jakarta) for input validation
- Prefer `spring-boot-starter-actuator` for metrics/health

## Configuration & Profiles

- Externalize configuration with environment vars / config server; never hardcode secrets
- Use profile-specific config: `application.yml`, plus minimal `application-{profile}.yml`
- Keep property keys stable; document breaking changes
- Fail fast on missing mandatory configuration via `@ConfigurationProperties` + `@Validated`
- Use constructor binding for `@ConfigurationProperties` classes

## AOT & Native Image Strategy

- Enable native support: include `org.graalvm.buildtools.native` Gradle plugin
- Use Spring AOT processing (`springAot`) and verify native build in CI
- Keep reflection usage explicit; add reachability metadata only when unavoidable
- Avoid dynamic proxies where possible (prefer interfaces with Spring-managed components). Consider using `native-hint` annotations when required.
- Log native build warnings; fail build if unsupported features appear (configure CI step)
- Limit runtime classpath scanning: use `@Import` or explicit `@Bean` definitions instead of broad component scanning where beneficial
- Avoid runtime generated bytecode frameworks not supported without configuration (e.g. CGLIB heavy custom use) beyond standard Spring usage

### Native Build Example (Gradle)

```kotlin
plugins {
	id("org.springframework.boot") version "3.3.0"
	id("io.spring.dependency-management") version "1.1.5"
	id("org.graalvm.buildtools.native") version "0.10.2"
	kotlin("jvm") version "1.9.24" // if using Kotlin
	kotlin("plugin.spring") version "1.9.24"
}

tasks.withType<JavaCompile> { options.release.set(17) }

graalvmNative {
	binaries {
		named("main") {
			imageName.set("service")
			buildArgs.add("--enable-http")
			buildArgs.add("--enable-https")
			resources.autodetect()
		}
	}
}
```

### Native Testing

- Add a native test execution stage (`bootBuildImage` or `nativeCompile` + run) in CI
- Run smoke tests against native binary (health, simple endpoint, metrics endpoint)
- Track native build time; fail if regression > threshold (e.g. +20%)

## Performance & Memory

- Favor constructor injection (better for AOT and testability)
- Use `record` (Java) / data classes (Kotlin) for DTOs to reduce boilerplate
- Avoid reflection / `Class.forName` / `ObjectMapper` dynamic polymorphic defaults when not needed
- Disable unused auto-configurations via `spring.autoconfigure.exclude` to shrink native image
- Configure connection pools explicitly (Hikari) size & timeouts; avoid unbounded growth
- Use pagination / streaming for large result sets; prefer `Chunked` or `Flux` for reactive
- For high concurrency adopt virtual threads (Java 21) with `spring.threads.virtual.enabled=true` (when stable for workload)

## Persistence

- Prefer Spring Data JDBC or JPA depending on complexity; for simple CRUD where lazy loading not needed choose JDBC for leaner model (native-friendly)
- Use Flyway or Liquibase for schema migrations; run on startup in controlled environments only
- Keep entity graphs tight; avoid bidirectional relationships unless required
- Avoid `EAGER` fetching—default to `LAZY` and fetch join explicitly
- Use projection interfaces or records over returning full entities to controllers

## REST & APIs

- Use `@RestController` with explicit `@RequestMapping` at class level
- Validate inputs with `@Valid` + Jakarta validation annotations
- Consistent error contract using `@ControllerAdvice` & problem+json style (RFC 7807) if feasible
- Return appropriate HTTP status codes; avoid 200 for error semantics
- Support pagination metadata in list endpoints (page, size, total)

## Security

- Adopt Spring Security 6 (Boot 3) – stateless JWT or opaque tokens via OAuth2 Resource Server
- Centralize security config; minimize custom filters
- Use method security with `@PreAuthorize` for domain-sensitive operations
- Store secrets in AWS Secrets Manager / Parameter Store; inject via environment or config import

## Observability

- Include Actuator endpoints: health, info, metrics, prometheus
- Tag metrics with minimal cardinality (service, region, environment)
- Expose tracing with OpenTelemetry auto-instrumentation (OTLP exporter) – no custom tracer singletons
- Define liveness & readiness probes for container platforms
- Redact sensitive fields in logs; use structured logging (JSON) in production

## Testing

- Unit tests: JUnit 5 + Mockito/Kotest (avoid loading Spring context unless needed)
- Slice tests (e.g. `@WebMvcTest`, `@DataJpaTest`) for focused integration
- Full integration tests: use `@SpringBootTest` with minimal profiles
- Use Testcontainers for external dependencies (Postgres, Kafka) – reuse containers across tests for speed
- For native: dedicated tests running the produced binary performing a minimal scenario suite

## Messaging & Async

- Prefer Spring Cloud Stream / Spring for Apache Kafka with explicit serialization classes
- Use retry/backoff policies; avoid infinite retries
- Use DLQs for poison messages
- For scheduling prefer `@Scheduled` minimal usage; consider managed platforms (EventBridge, CloudWatch Events) for distributed scheduling

## Cloud & AWS Integration

- Use AWS SDK v2; avoid blocking on reactive pipelines (choose one paradigm: imperative or reactive)
- Externalize AWS endpoint & region configuration
- Avoid embedding AWS credentials; rely on IAM roles

## Configuration Properties Example

```kotlin
@ConfigurationProperties("app.feature")
@Validated
data class FeatureProperties(
	@field:NotBlank val mode: String,
	@field:Min(1) @field:Max(60) val timeoutSeconds: Int = 10
)
```

## Deprecated / Avoid

- `javax.*` imports – must be migrated
- Field injection (`@Autowired` on fields)
- Wildcard component scanning of broad packages (`@SpringBootApplication(scanBasePackages = ["com.company"])` with huge root) – be intentional
- Unbounded thread pools / custom executors without metrics
- Returning JPA entities directly from controllers
- Business logic inside controllers or repositories

## Migration Notes (2.x -> 3.x)

- Replace `javax` with `jakarta` imports (Servlet API, JPA, Validation)
- Update security configuration: `WebSecurityConfigurerAdapter` removed – use `SecurityFilterChain` bean
- Actuator endpoint IDs may have changed; verify monitoring dashboards
- Adjust CORS & SameSite cookie config to new APIs if using security
- Review deprecations removed in Boot 3 (legacy metrics, binding APIs)

## CI/CD

- Include steps: compile, unit tests, integration tests (JVM), native build, native smoke tests
- Cache `~/.gradle` and native image build layers (if using buildpacks) for speed
- Fail pipeline on any TODO/FIXME (optional static check)

## Quality Gates

- Static analysis: Spotless / ktlint / Checkstyle, Detekt (Kotlin) – enforce formatting pre-commit
- Security scanning: OWASP Dependency Check / Snyk in pipeline
- Minimum test coverage thresholds (line/branch) defined at repo root

## Example Security Config (No WebSecurityConfigurerAdapter)

```kotlin
@Bean
fun filterChain(http: HttpSecurity): SecurityFilterChain = http
	.csrf { it.disable() }
	.authorizeHttpRequests { auth ->
		auth.requestMatchers("/actuator/health", "/actuator/info").permitAll()
			.anyRequest().authenticated()
	}
	.oauth2ResourceServer { it.jwt() }
	.build()
```

## Virtual Threads (Optional - Java 21)

- Evaluate with realistic load before enabling
- Enable via property (when supported): `spring.threads.virtual.enabled=true`
- Avoid blocking operations inside virtual threads that hold scarce resources

## Checklist Before Release

- [ ] All `javax.*` removed
- [ ] Native image build passes & smoke tests green
- [ ] Actuator endpoints secured & accessible
- [ ] Configuration properties validated
- [ ] DB migrations applied in staging
- [ ] Observability (metrics, traces, logs) verified
- [ ] Performance baseline captured (JVM vs native if both distributed)
